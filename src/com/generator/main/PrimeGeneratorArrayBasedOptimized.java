package com.generator.main;

/**
 * Условно "бесконечный" генератор простых чисел. Объект для перебора
 * представляет из себя двухмерный массив. Первый индекс - текущее нечётное
 * простое число, второй индекс (вложенный массив) простые множители данного
 * числа. Фактически "бесконечность" ограничена тем, что наступит раньше: 1)
 * ограничение объёма heap-памяти JVM, 2) достижение предела ёмкости массива
 * Integer.MAX_VALUE (уменьшенное на 1, 2 - зависит от окружения...)
 * 
 * Оптимизированная версия - в перебираемом массиве нечётные числа записываются
 * подряд.
 * 
 * Некоторые зависимости из-за того, что в массиве не представлены нечётные
 * числа: 
 * - значение нечётного число на индексе i: 2 * i + 3. 
 * - индекс нечётного полного квадрата: (x^0.5 - 3) / 2. 
 * - индекс "проброшенного" числа pr с позиции i на позицию i*i: i + (pr * (i + 1)). 
 * - индекс "проброшенного" числа pr с позиции i на позицию 2*pr: i + pr.
 * 
 * Запуск с ключом -Xmx12000m (12 Гб на heap) для size = 250_000_000.
 * 
 * @author bratishka
 * @version 1.0
 */
public class PrimeGeneratorArrayBasedOptimized implements Runnable {
	// Максимальное количество чисел для проверки (квази-бесконечный массив)
	// Integer.MAX_VALUE = 2_147_483_647, при -1 происходит ошибка "Requested
	// array size exceeds VM limit"
	private int size = 250_000_000;
	// Максимальное количество простых множителей каждого числа-кандидата проверки
	private int max_primes = 5;
	// Счётчик найденных целых чисел
	private int count = 0;
	// Текущее проверяемое простое число
	private int curr = 0;
	// Массив с перебираемыми числами (с подмассивами простых делителей). Вложенные
	// массивы требуются для учёта нескольких простых множителей при "пробросе"
	// простого числа вперёд. Подмассив с простыми множителями имеет размер в
	// max_primes
	private int[][] cand = new int[size][max_primes];

	@Override
	public void run() {
		for (;;) {
			// У текущего числа-кандидата ранее не было найдено простых множителей
			if (cand[curr][0] == 0) {
				int temp = 2 * curr + 3;
				cand[curr][0] = temp;

				// Сдвиг на позицию curr * curr с учётом прорежённого массива (чётный чисел в
				// cand[] нет): i + (pr * (i + 1))
				int next_index = curr + cand[curr][0] * (curr + 1);
				cand[next_index][0] = temp;
				count++;

				Starter.logger.info("PRIME={}, count={}", temp, count);
			} else {
				// Подмассив с простыми делителями не пустой. Необходимо перенести все
				// делители на соответствующий шаг (cand[curr][i]) вперёд

				// Перебор уже записанных простых множителей текущего кандидата
				for (int i = 0; i < cand[curr].length; i++) {
					// Индекс целевого кандидата, куда "пробрасывается" данный простой множитель
					int next_index = curr + cand[curr][i];
					// Поиск последнего элемента в целевом кандидате, чтобы записать в конец
					int sub = 0;
					while (cand[next_index][sub] != 0) {
						sub++;
					}
					// "Пробрасываем" данный простой делитель
					cand[next_index][sub] = cand[curr][i];
				}
			}
			curr++; // Переход к следующему нечётному кандидату на простое число
		}
	}
}
