package com.generator.main;

<<<<<<< HEAD
=======
import java.math.BigInteger;

>>>>>>> refs/heads/Generator1
/**
 * Условно "бесконечный" генератор простых чисел. Объект для перебора
 * представляет из себя двухмерный массив. Первый индекс - текущее простое
 * число, второй индекс (вложенный массив) простые множители данного числа.
 * Фактически "бесконечность" ограничена тем, что наступит раньше: 1)
 * ограничение объёма heap-памяти JVM, 2) достижение предела ёмкости массива
 * Integer.MAX_VALUE (уменьшенное на 1, 2 - зависит от окружения...)
 * 
 * Неоптимизированная версия - в перебираемом массиве на чётных позициях остаются
 * "дырки".
 * 
 * Перед попыткой записать в массив с элементом curr * curr - проверка на
 * переполнение int (индекс не должен быть больше Integer.MAX_VALUE^0.5, т.е.
 * 46341). Фактически никогда не сработает - не удалось запустить JVM с
 * "адекватными" параметрами по объёму памяти для достижения предела.
 * 
 * Запуск с ключом -Xmx12000m (12 Гб на heap) для size = 200_000_000.
 * 
 * @author bratishka
 * @version 1.0
 */
public class PrimesGeneratorArrayBased implements Runnable {
	// Максимальное количество чисел для проверки (квази-бесконечный массив)
	// Integer.MAX_VALUE = 2_147_483_647, при -1 происходит ошибка "Requested
	//  array size exceeds VM limit"
	private int size = 50_000_000;
	// Максимальное количество простых множителей каждого числа-кандидата проверки
	private int max_primes = 7;
	// Счётчик найденных целых чисел
	private int count = 0;
	// Текущее проверяемое простое число
	// Начинаем проверку с 3, проверяем только нечётные числа
	private int curr = 3;
	// Массив с перебираемыми числами (с подмассивами простых делителей). Вложенные
	// массивы требуются для учёта нескольких простых множителей при "пробросе"
	// простого числа вперёд. Подмассив с простыми множителями имеет размер в max_primes
	private int[][] cand = new int[size][max_primes];

	@Override
	public void run() {		
		for (;;) {
			// У текущего числа-кандидата ранее не было найдено простых множителей
			if (cand[curr][0] == 0) {
				cand[curr][0] = curr;
				// Чтобы не переполнять int, "пробрасывать" будем только в случае отсутствия
				// переполнения curr * curr
				long next_index = (long) curr * curr;
				if(next_index < size) {
					cand[curr * curr][0] = curr;
				}
				count++;
				Starter.logger.info("PRIME={}, count={}", curr, count);
			} else {
				// Подмассив с простыми делителями не пустой. Необходимо перенести все
				// делители на соответствующий шаг (2 * cand[curr][i]) вперёд

				// Перебор уже записанных простых множителей текущего кандидата
				for (int i = 0; i < cand[curr].length; i++) {
					// Индекс целевого кандидата, куда "пробрасывается" данный простой множитель
					long next_index = curr + cand[curr][i] * 2L;
					
					// Индекс вышел за пределы массива - переходим на следующую итерацию
					if (next_index >= size) {
						continue;
					}
					
					// Поиск последнего элемента в целевом кандидате, чтобы записать в конец
					int sub = 0;
					while (cand[(int) next_index][sub] != 0) {
						sub++;
					}
					// "Пробрасываем" данный простой делитель
					cand[(int) next_index][sub] = cand[curr][i];
				}
			}
			curr = curr + 2; // Переход к следующему нечётному кандидату на простое число
			
			// Выход за пределы массива - дальше проверять нечего
			if (curr >= size) {
				return;
			}
		}
	}
}
