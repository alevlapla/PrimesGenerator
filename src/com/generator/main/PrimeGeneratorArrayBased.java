package com.generator.main;

import java.math.BigInteger;

/**
 * Условно "бесконечный" генератор простых чисел. Объект для перебора
 * представляет из себя двухмерный массив. Первый индекс - текущее простое
 * число, второй индекс (вложенный массив) простые множители данного числа.
 * Фактически "бесконечность" ограничена тем, что наступит раньше: 1)
 * ограничение объёма heap-памяти JVM, 2) достижение предела ёмкости массива
 * Integer.MAX_VALUE (уменьшенное на 1, 2 - зависит от окружения...)
 * 
 * Неоптимальная версия - в перебираемом массиве на чётных позициях остаются
 * "дырки".
 * 
 * Перед попыткой записать в массив с элементом curr * curr - проверка на
 * переполнение int (индекс не должен быть больше Integer.MAX_VALUE^0.5, т.е.
 * 46341). Фактически никогда не сработает - не удалось запустить JVM с
 * "адекватными" параметрами по объёму памяти для достижения предела.
 * 
 * Запуск с ключом -Xmx12000m (12 Гб на heap) для size = 200_000_000.
 * 
 * @author bratishka
 * @version 1.0
 */
public class PrimeGeneratorArrayBased implements Runnable {
	// Максимальное количество чисел для проверки (квази-бесконечный массив)
	// При -1 происходит ошибка "Requested array size exceeds VM limit"
	// Integer.MAX_VALUE = 2_147_483_647
	private int size = 200_000_000;
	// Максимальное количество простых множителей каждого числа-кандидата проверки
	private int max_primes = 4;
	// Счётчик найденных целых чисел
	private int count = 0;

	// Текущее проверяемое простое число
	// Начинаем проверку с 3, проверяем только нечётные числа
	// TODO Перебирать только нечётные числа, чтобы не было "дырок" в массиве
	private int curr = 3;

	// Массив с перебираемыми числами (с подмассивами простых делителей). Вложенные
	// массивы требуются для учёта нескольких простых множителей при "пробросе"
	// простого числа вперёд. Подмассив с простыми множителями имеет размер в max_primes
	private int[][] cand = new int[size][max_primes];

	@Override
	public void run() {
		for (;;) {
			// У текущего числа-кандидата ранее не было найдено простых множителей
			if (cand[curr][0] == 0) {
				cand[curr][0] = curr;
				// Чтобы не переполнять int, "пробрасывать" будем только в случае отсутствия
				// переполнения curr * curr
				if (curr < 46341) {
					cand[curr * curr][0] = curr;
				}
				count++;
				Starter.logger.info("PRIME={}, count={}", curr, count);
			} else {
				// Подмассив с простыми делителями не пустой. Необходимо: 1) перенести все
				// делители на соответствующий шаг (2 * cand[curr][i]) вперёд, 2) учесть уже
				// присутствующие простые множители, чтобы не было дублей

				// Перебор уже записанных простых множителей текущего кандидата
				for (int i = 0; i < cand[curr].length; i++) {
					// Индекс целевого кандидата, куда "пробрасывается" данный простой множитель
					int next_index = curr + cand[curr][i] * 2;
					// Поиск последнего элемента в целевом кандидате, чтобы записать в конец.
					// Попутная проверка наличия данного простого делителя в кандидате
					int sub = 0;
					while (cand[next_index][sub] != 0) {
						sub++;
					}
					// "Пробрасываем" данный простой делитель
					cand[next_index][sub] = cand[curr][i];
				}
			}
			curr = curr + 2; // Переход к следующему нечётному кандидату на простое число
		}
	}
}
