package com.generator.bithell;

import java.util.Iterator;

/* Оператор "== 0 >>> 0" приводит левый ноль к int (перед смещением, т. е. умножением на 2^0 = 1, а затем сравнивает? */
/**
 * Классическое решето Эратосфена (без каких-либо оптимизаций).
 * <p>
 * Решето организовано на битах. Если при проверке очередного числа-кандидата,
 * бит, соответствующий этому числу-кандидату так и не был установлен (т. е. бит
 * равен {@code 0}), то число-кандидат, соответствующее данному биту является
 * простым.
 * <p>
 * В качестве опорного типа для учёта массива бит используется тип {@code byte}.
 * Таким образом, при извлечении {@code byte[0]} мы получаем доступ к битам №
 * {@code 0-7}, при извлечении {@code byte[1]} мы получаем доступ к битам №
 * {@code 8-15} и т. д.
 * <p>
 * Так как работа алгоритма основана на арифметике с модулем {@code 8} (ёмкость
 * типа {@code byte}), то применимы следующие операции:<br>
 * 1) {@code >> 3} эквивалентно делению на {@code 2^3 = 8}. Таким образом можно
 * извлечь нужный набор из {@code 8}-ми бит.<br>
 * 2) {@code 1 << (i & 7))} позволяет преобразовать произвольный индекс
 * {@code i} числа-кандидата в порядковый номер бита (маска {@code 7 = 0b0111}
 * извлечёт младшие {@code 3} бита {@code i}, т. е. значение от {@code 0} до
 * {@code 7}) данной восьмёрки бит {@code byte[i >> 3]}, который соответствует
 * данному числу-кандидату.<br>
 * Другими словами, данная операция возвращает остаток {@code i % 8}, ведь
 * известно, что {@code a % b = a & (b -
 * 1)} или {@code i % 8 = i & (8 - 1)}. Дальнейший сдвиг {@code 1} налево на
 * данный остаток деления возвратит маску, где единственный установленный бит
 * занимает место бита, соответствующее данному числу-кандидату в данной
 * восьмёрке бит {@code byte[i >> 3]}.
 * <p>
 * Так как работа алгоритма основана на массиве бит, учитывающем только нечётные
 * числа, то применимы следующие зависимости:<br>
 * 1) Число-кандидат {@code p}, восстановленное из индекса бита {@code i}:
 * {@code p = i + i + 3}, где {@code 3} - значение, соответствующее нулевому
 * биту.<br>
 * 2) Индекс квадрата простого числа {@code p: i = (p * p - 3) / 2}, где
 * {@code 3} - значение, соответствующее нулевому биту. Подставив выражение 1) в
 * 2): {@code ((i + i + 3) * (i * + i + 3) - 3) / 2 = 2 * i ^ 2 + 6 * i + 3 = 2
 * * i * (i + 3) + 3}. Или {@code sqri = (i << 1) * (i + 3) + 3}.
 * <p>
 * Например: {@code i = 11} соответствует числу-кандидату {@code p = 11 + 11 + 3
 * = 25}, индекс квадрата которого {@code sqri = (25 * 25 - 3) / 62 = 311}, а
 * последовательность байт {@code byte[11 >> 8] = byte[1]}, и маска битов в
 * данной последовательности байт {@code 0b0000_1000} (бит смещается на {@code
 * 11 % 8 = 3} разряда влево).
 * 
 * @author GordonBGood (<a href=
 *         "https://stackoverflow.com/questions/39312107/implementing-the-page-segmented-sieve-of-eratosthenes-in-javascript">StackOverflow</a
 *         href>)
 * 
 * @author bratishka
 * @version 1.0
 */
public class BitSieve implements Iterator<Long>, Iterable<Long> {
	/* Последнее проверяемое число. */
	private final long limit = 20;
	/*
	 * Индекс бита, который соответствует последнему числу-кандидату с учётом того,
	 * что первое число-кандидат - 3, а сами биты отображают только нечётные
	 * числа-кандидаты. Например, для limit = 20 последнее нечётное число - 19 имеет
	 * индекс 8.
	 */
	private final long lmti = (limit - 3) >> 1; // (limit - 3) / 2
	/*
	 * Размер опорного массива типа byte[] в байтах: количество бит lmti делится на
	 * 2^3 = 8 округлением вверх до целого байта. Например, при индексе последнего
	 * бита lmti = 7 (всего 7 бит), размер будет 1 байт. А при lmti = 8 (всего 9
	 * бит), размер будет 2 байта.
	 */
	private final long size = (lmti >> 3) + 1; // lmti / 2^3 + 1
	/*
	 * Массив бит, где каждый бит отображает число-кандидат (инициализирован
	 * значениями "0"). В массиве только нечётные числа: i=0 -> 3, i=1 -> 5, i=2 ->
	 * 7... Восстановление числа-кандидата p: p = i + i + 3, где i - индекс элемента
	 * в массиве, 3 - значение, соответствующее нулевому биту.
	 */
	private final byte[] cmpsts = new byte[(int) size];
	/*
	 * Внутреннее состояние итератора - индекс бита, который соответствует
	 * последнему проверенному числу-кандидату. Начальное значение -1 для особой
	 * обработки простого числа "2".
	 */
	private long bi = -1;

	@Override
	public boolean hasNext() {
		return true; // Бесконечная итерация.
	}

	@Override
	public Long next() {
		/*
		 * Бесконечный цикл, последовательно перебирающий индексы битов.
		 */
		for (long i = 0;; ++i) {
			// p - число-кандидат, восстановленное из индекса данного бита.
			long p = i + i + 3;
			/*
			 * Индекс бита, который соответствует квадрату числа-кандидата p, находится по
			 * формуле: i = (p * p - 3) / 2, где p - простое число, 3 - значение,
			 * соответствующее нулевому биту. Преобразуя выражение: ((i + i + 3) * (i + i +
			 * 3) - 3) / 2 = 2 * i^2 + 6 * i + 3 = 2 * i * (i + 3) + 3
			 */
			long sqri = (i << 1) * (i + 3) + 3;
			/*
			 * Если индекс текущего бита стал больше индекса последнего бита - то мы вышли
			 * за предел массива cpsts[] проверяемых чисел.
			 */
			if (sqri > lmti)
				break;
			/*
			 * Выражение: 1) (cmpsts[(int) i >> 3] извлекает восьмёрку бит, к которой
			 * относится данный индекс бита i. Например, i = 0...7 -> первая восьмёрка бит,
			 * i = 8...15 -> вторая восьмёрка бит и т. д. 2) (1 << (i & 7)) создаёт восьми
			 * битную маску, где установлен только один бит. Позиция этого бита
			 * соответствует индексу числа-кандидата в данной конкретной восьмёрке бит
			 * (вычисление эквивалентно i % 8). Если данный бит не установлен - т. е. число
			 * простое, то & всегда будет возвращать 0. Если число составное. т. е. бит
			 * установлен - то равенство нулю никогда не будет.
			 */
			if ((cmpsts[(int) i >> 3] & (1 << (i & 7))) == 0) {
				/*
				 * Бит с индексом i после проверки оказался равен нулю, значит число-кандидат,
				 * соответствующее этому биту, является простым. Все числа, которые больше
				 * квадрата этого числа-кандидата с шагом этого числа-кандидата, являются
				 * составными (устанавливаем соответствующие биты).
				 */
				for (long c = sqri; c <= lmti; c += p) {
					/*
					 * Для этого перезапишем данную восьмёрку битов, установив соответствующий бит
					 * дизъюнкцией.
					 */
					cmpsts[(int) c >> 3] |= 1 << (c & 7);
				}
			}
		}
		/*
		 * Особо обрабатываем первый запрос - возврат единственного чётного простого
		 * числа "2".
		 */
		if (bi < 0) {
			++bi;
			return Long.valueOf(2);
		}
		/*
		 * Поиск очередного не равного нулю бита: перебор всех битов начиная с последней
		 * позиции bi. В условии извлекается восьмёрка бит, к которой принадлежит индекс
		 * bi. Далее составляется маска с единственным установленным битом на позиции,
		 * соответствующей данному индексу. Пока данное число-кандидат с индексом bi
		 * составное - то оно имеет установленный бит, а значит условие не может быть
		 * выполнено. Переход к следующему биту.
		 */
		while (bi <= lmti && (cmpsts[(int) bi >> 3] & (1 << (bi & 7))) != 0) {
			++bi;
		}
		if (bi > lmti)
			return null; // Вышли за пределы compsts[].

		/*
		 * Возврат текущего простого числа с переходом к следующему индексу bi. Число
		 * восстанавливается по формуле: p = 2*bi + 3, где 3 - значение, соответствующее
		 * нулевому биту.
		 */
		return (bi++ << 1) + 3;
	}

	@Override
	public Iterator<Long> iterator() {
		return this;
	}
}