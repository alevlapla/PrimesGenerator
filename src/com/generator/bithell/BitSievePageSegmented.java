package com.generator.bithell;

import java.util.Iterator;
import java.util.ArrayList;
import java.util.List;

import com.generator.main.Starter;

/**
 * Сегментированное решето Эратосфена. Просеиваются только нечётные числа.
 * Бесконечное множество нечётных чисел нарезается на страницы одинаковых длин
 * (массивы бит равных размеров). Страница содержит {@code PGSZBITS} бит или
 * {@code PGSZZBYTES} байт. Программно страница представлена массивом типа
 * {@code byte[]}, где каждое число -128...127 занимает один байт (8 бит) и
 * отображает 8 нечётных чисел-кандидатов (биты следуют справа налево).
 * <p>
 * При предложенных величинах {@code PGSZBITS} и {@code PGSZZBYTES} каждая
 * страница представляет из себя:<br>
 * № 0: индексы бит {@code bi} [0...1_048_576), байты [0...131_072) нечётные
 * числа [3...2_097_155),<br>
 * № 1: индексы бит {@code bi} [1_048_576...2_097_152), байты
 * [131_072...262_144) нечётные числа [2_097_155...4_194_307),<br>
 * № 2: и т. д.
 * <p>
 * Дополнительные параметры каждой страницы:<br>
 * 1) индекс начального бита страницы {@code lowi}. Для нулевой страницы {@code
 * lowi = 0}, для первой {@code lowi = PGSZBITS}, для второй {@code lowi = 2 *
 * PGSZBITS} и т. д.<br>
 * 2) максимальное нечётное число, являющейся границей данной страницы или
 * первым числом следующей страницы, {@code nxt =
 * 3 + (lowi + PGSZBITS) * 2}, где {@code 3} - начальное число нулевой страницы,
 * а удвоенная сумма представляет количество чисел с учётом чётных чисел.
 * <p>
 * При каждом вызове {@code next()} алгоритм может работает в одном из пяти
 * следующих режимах.
 * <p>
 * Режим № 1 ({@code bi = -1}). Первый вызов {@code next()} после создания
 * объекта итератора. По short-circuit возвращается единственное чётное простое
 * число {@code 2}.
 * <p>
 * Режим № 2 ({@code bi = 0}). Второй вызов {@code next()} после создания
 * объекта итератора или первый вызов после создания новой страницы. Всегда
 * вычисляется максимальное нечётное число данной страницы {@code nxt} и
 * обнуляется решето данной страницы {@code byte[] buf}. Дальнейшие действия
 * зависят от значения индекса начала страницы {@code lowi}. Если
 * {@code lowi <= 0}, то это первый проход после создания объекта итератора, и
 * необходимо особым образом просеять решето {@code byte[] buf}.<br>
 * Это требуется для того, чтобы можно было создать внутренний генератор простых
 * чисел {@code bps}, который при последующих вызовах {@code next()} будет
 * заполнять опорный массив простых чисел {@code bpa}. Во внешнем же итераторе
 * при последующих вызовах {@code next()}, мы впредь будем использовать только
 * простые числа из опорного массива простых чисел {@code bpa}.<br>
 * Если {@code lowi > 0}, то мы уже не на нулевой странице и обработка
 * {@code byte[]
 * buf} в данном месте не требуется.
 * <p>
 * Режим № 3 ({@code 0 < bi < PGSZBITS}, {@code bpa} пустой). При третьем вызове
 * {@code next()} с момента создания объекта итератора в объекте уже подготовлен
 * просеянный массив {@code byte[] buf}, который будет использоваться в
 * генераторе базовых простых чисел {@code bps}. Происходит инициализация
 * генератора базовых простых чисел {@code bps} и начальное заполнение опорного
 * массива простых чисел {@code bpa}.
 * <p>
 * Режим № 4 ({@code 0 < bi < PGSZBITS}, {@code bpa} не пустой). При последующих
 * вызовах {@code next()} происходит дальнейшее заполнение {@code bpa} при
 * помощи генератора базовых простых чисел {@code bps}: добавляются простые
 * числа (начиная с последнего добавленного в {@code bpa} простого числа),
 * квадраты которых меньше числа-границы данной страницы {@code nxt}.<br>
 * Затем из {@code bpa} последовательно извлекаются простые числа, определяются
 * индексы их квадратов и начинается "классическое" просеивание текущей страницы
 * (фрагмента бесконечного решета), начиная с квадратов, с шагом простого числа.
 * Если в данный момент просеивается не нулевая страница, то может потребоваться
 * корректировка индекса квадрата простого числа для его "протягивания" (если
 * индекс квадрата меньше индекса начала страницы) или его "проецирования" (если
 * индекс квадрата больше индекса начала страницы). После корректировки, индекс
 * квадрата простого числа, с которого начнётся просеивание страницы, всегда
 * будет находиться в пределах массива {@code byte[] buf}.<br>
 * После просеивания выполняется перебор страницы {@code byte[] buf} в поиске
 * очередного неустановленного бита (индекс которого {@code bi} соответствует
 * простому числу).
 * <p>
 * Режим № 5 ({@code bi >= PGSZBITS}). При выполнении действий режима № 4 может
 * оказаться, что очередной индекс бита оказался за диапазоном данной страницы
 * {@code bi > lowi}. В таком случае создаётся новая страница с вычислением
 * максимального нечётного числа очередной страницы {@code nxt} и обнулением
 * решета данной страницы {@code byte[] buf} (рекурсивный вызов {@code next()}).
 * 
 * @author GordonBGood (<a href=
 *         "https://stackoverflow.com/questions/39312107/implementing-the-page-segmented-sieve-of-eratosthenes-in-javascript">StackOverflow</a
 *         href>)
 * @author bratishka
 * @version 1.0
 */
public class BitSievePageSegmented implements Iterator<Long> {
	/* Номер текущей страницы. */
	private int counter = 0;
	/*
	 * Счётчик найденных простых чисел. Увеличивается только при создании очередной
	 * страницы путём вызова метода countPage().
	 */
	private int prcounter = 0;
	/*
	 * Размер страницы в байтах. Размер произвольный?. 16384 * 8 = 2^14 * 2^3 = 2^17
	 * = 131_072. Соответствует размеру решета byte[] buf, т. к. каждый байт
	 * отображает 8 бит или 8 нечётных чисел-кандидатов.
	 */
	final int PGSZBYTES = 16384 * 8;
	/* Размер страницы в битах. 2^14 * 2^3 * 2^3 = 1_048_576. */
	final int PGSZBITS = PGSZBYTES * 8;
	/*
	 * Страница - битовый массив, который представляет "решето" из нечётный чисел
	 * (для нулевой страницы - начиная с трёх). Если число оказалось составным, то
	 * соответствующий ему бит будет установлен. Массив обрабатывается двумя
	 * способами: 1) когда lowi <= 0: просеивается от 0 до тех пор, пока квадрат
	 * данного нечётного числа sqr меньше границы нулевой страницы nxt, 2) lowi > 0:
	 * просеивается на основании чисел из bpa, с соответствующей корректировкой
	 * начального индекса для просеивания ненулевой страницы.
	 */
	private final byte[] buf = new byte[PGSZBYTES];
	/*
	 * Массив базовых простых чисел (base prime array). Используются для накопления
	 * простых чисел, полученных из внутреннего генератора базовых простых чисел.
	 */
	private final List<Integer> bpa = new ArrayList<>();
	/*
	 * Генератор базовых простых чисел (base prime stream). Используется для
	 * накопления простых чисел в bpa. Создаётся только один раз, когда bpa пустой.
	 */
	private Iterator<Long> bps;
	/*
	 * Индекс бита нижней границы текущей страницы. Соответствует нечётному числу
	 * nxt следующей страницы.
	 */
	private long lowi = 0;
	/*
	 * Индекс обрабатываемого бита. Значение "-1" для особой обработки единственного
	 * чётного простого числа "2". При последующих вызовах на данном объекте
	 * итератора, значение "-1" получить невозможно. При создании новой страницы: bi
	 * = 0.
	 */
	private long bi = -1;

	/*
	 * Таблица поиска, используемая в подсчёте найденных простых чисел на странице.
	 * Представляет из себя массив с числами, где каждый элемент отображает
	 * количество установленных бит своего индекса.
	 */
	private final static int[] CLUT = generateCLUT();

	@Override
	public boolean hasNext() {
		return true; // Бесконечная итерация.
	}

	@Override
	public Long next() {
		/*
		 * Если bi < 1, то это значит, что: bi = -1 и мы должны обработать особым
		 * образом единственное чётное простое число "2". bi = 0 и мы начали
		 * обрабатывать новую страницу. Для обработки новой страницы необходимо
		 * вычислить последнее число страницы и обнулить byte[] buf.
		 */
		if (bi < 1) {
			/*
			 * Если индекс байта bi отрицательный - то мы должны обработать особый случай -
			 * возврат единственного чётного простого числа "2".
			 */
			if (bi < 0) {
				bi = 0;
				return 2L;
			}

			/*
			 * Нечётное число-граница страницы (равно нулевому числу-кандидату следующей
			 * страницы). Учитываются начальное число 3, смещение страницы (индекс
			 * начального бита lowi), количество бит на странице (PGSZBITS) и чётные числа
			 * (умножение на 2). Далее эта верхняя граница используется в сравнениях
			 * квадратов простых чисел sqr.
			 */
			long nxt = 3 + ((lowi + PGSZBITS) << 1);

			Starter.logger.info(
					"Инициализация страницы № {}.\n...индексы бит: [{}, {}), значения: [{}, {}) (кол-во бит/нечётных чисел: {}).\n...индекс начала страницы (нулевой бит) lowi={}, последнее число nxt={}.\nprcounter={}.",
					counter, lowi, lowi + PGSZBITS, 2 * lowi + 3, 2 * (lowi + PGSZBITS) + 3, PGSZBITS, lowi, nxt,
					prcounter);

			/* Очистка массива решета. */
			for (int i = 0; i < buf.length; i++)
				buf[i] = 0;

			/*
			 * Особая обработка нулевой страницы, т. к. пока ещё нет базовых простых чисел
			 * (bpa пустой). Нужна для того, чтобы заполнить byte[] buff для внутреннего
			 * генератора базовых простых чисел bps.
			 */
			if (lowi <= 0) {

				Starter.logger.info("Особая обработка нулевой страницы lowi={} (подготовка byte[] buf).", lowi);

				/*
				 * Проходим биты нулевой страницы, где i - индекс бита, p - нечётное число,
				 * соответствующее данному биту страницы, sqr - квадрат данного простого
				 * нечётного числа p.
				 */
				for (int i = 0, p = 3, sqr = 9; sqr < nxt; ++i, p += 2, sqr = p * p) {
					/*
					 * Если очередная извлечённая восьмёрка бит, соответствующая данному индексу i,
					 * не имеет очередной установленный бит на позиции, соответствующей данному
					 * индексу i внутри данной извлечённой восьмёрки бит (т. е. 0 & 1 == 0), то
					 * число-кандидат p, соответствующее данному индексу бита, является простым.
					 * Порядок бит справа налево.
					 */
					if ((buf[i >> 3] & (1 << (i & 7))) == 0) {

						Starter.logger.info("   \"0\" для i={}, p={}, вычёркивание от sqr={}, 8-ка бит №{}: {}.", i, p,
								sqr, i >> 3, decToBinRaw(buf[i >> 3]));

						/*
						 * А если данное число-кандидат p с индексом бита i является простым, то
						 * необходимо просеять его начиная с квадратного корня с шагом простого числа.
						 * (sqr - 3) >> 1 - нахождение индекса бита, соответствующего квадрату
						 * числа-кандидата sqr, i = (sqr - 3) / 2. Т. к. данная инициализация byte[] buf
						 * будет происходить только единожды, то нам не нужно корректировать индексы по
						 * lowi (учитываем только длину нулевой страницы PGSZBITS).
						 */
						for (int j = (sqr - 3) >> 1; j < PGSZBITS; j += p) {
							/*
							 * Из buf извлекается восьмёрка бит, соответствующая индексу бита j,
							 * устанавливается бит на позиции, которая соответствует индексу бита j, и
							 * модифицированная восьмёрка бит записывается обратно.
							 */
							buf[j >> 3] |= 1 << (j & 7);
						}
					}
				}

				Starter.logger.info("Подготовка byte[] buf завершена.");
			}
			/* Для страниц после нулевой: № 1, 2, 3... обработка иная (lowi > 0). */
			else {

				Starter.logger.info("byte[] buf уже подготовлен (текущая страница №{}).", counter);

				/*
				 * Если это только первая страница после нулевой, то необходимо создать
				 * генератор bps для заполнения bpa.
				 */
				if (bpa.isEmpty()) {

					Starter.logger.info("===СОЗДАНИЕ ОПОРНОГО ГЕНЕРАТОРА===");

					/*
					 * base prime stream. Генератор базовых простых чисел, которые будут добавляться
					 * в массив bpa (чтобы не генерировать опорные простые числа каждый вызов
					 * next()).
					 */
					bps = new BitSievePageSegmented();
					bps.next(); // Смещаемся мимо первого числа - простого чётного "2".
					bpa.add(bps.next().intValue()); // Записываем следующее простое число "3".

					Starter.logger.info("===ОПОРНЫЙ ГЕНЕРАТОР СОЗДАН===");

				}

				/*
				 * Необходимо заполнить bpa путём извлечения из генератора базовых простых чисел
				 * очередной порции простых чисел. Из bpa извлекается последнее записанное в
				 * него простое число p. Если квадрат данного простого числа sqr меньше
				 * числа-границы страницы nxt, то из генератора извлекается следующее простое
				 * число, возводится в квадрат и т. д., пока квадрат очередного извлечённого
				 * простого числа не выйдет за пределы страницы.
				 */

				Starter.logger.info("===ВЫЗОВЫ next() ДЛЯ ЗАПОЛНЕНИЯ bpa===");

				for (long p = bpa.get(bpa.size() - 1), sqr = p * p; sqr < nxt; p = bps.next(), bpa
						.add((int) p), sqr = p * p) {
					Starter.logger.info("...запись в bpa простого числа (пока sqr < nxt) p={}, sqr={}, nxt={}", p, sqr,
							nxt);
				}
				;

				Starter.logger.info("===ВЫЗОВЫ next() ДЛЯ ЗАПОЛНЕНИЯ bpa ОКОНЧЕНЫ===");

				/*
				 * Перебор простых чисел из bpa.
				 */
				for (int i = 0; i < bpa.size() - 1; i++) {
					// Очередное базовое простое число.
					long p = bpa.get(i);
					/*
					 * Индекс квадрата данного базового простого числа: i = (p * p - 3) / 2 - с него
					 * начнём просеивать обнулённый в начале метода byte[] buf.
					 */
					long s = (p * p - 3) >>> 1;

					Starter.logger.info("Проход bpa: i={}, простое число p={}, индекс его квадрата s={}, lowi={}", i, p,
							s, lowi);
					/*
					 * Так как здесь обрабатывается уже не первая страница (lowi > 0), индекс
					 * квадрата простого числа может оказаться: до данной страницы (s < lowi), или
					 * на данной странице (s >= lowi). Для просеивания массива byte[] buf необходимо
					 * индексы квадратов s "спроецировать" на нулевую страницу с индексами [0,
					 * PGSZBITS). Для случая s >= lowi по правилам модульной арифметики мы можем
					 * просто исключить очередной "круг" размером PGSZBITS = 1_048_576.
					 */
					if (s >= lowi) {
						s -= lowi;

						Starter.logger.info(
								"Индекс квадрата s стал больше lowi. Уменьшим его на lowi. После уменьшения p={}, s={}, lowi={}.",
								p, s, lowi);

					} else {
						/*
						 * Квадрат простого числа не попал на текущую страницу. Мы пытались возвести в
						 * квадрат p, получили sqr, которое меньше lowi. Необходимо "продвинуть" sqr до
						 * данной страницы (чтобы оно стало больше lowi), чтобы иметь индекс на
						 * странице, с которого начать просеивание.
						 * 
						 * Здесь мы находим разницу между индексом квадрата числа и индексом начала
						 * страницы. Начиная с s данный интервал просеивается с шагом простого числа p.
						 * Необходимо понять, какой индекс будет иметь первое просеиваемое число на
						 * новой странице (когда будет s > lowi).
						 * 
						 * Например, страница № 0 для числа 3: [3, 2_097_155) - последнее нечётное
						 * число, кратное 3: 2_097_153. На следующей странице № 1 [2_097_155, 4_194_307)
						 * необходимо продолжить вычёркивать нечётные числа с шагом 3 начиная с индекса
						 * бита bi = p - r = 3 - (2_097_155 - 3^2) % 3 = 1.
						 * 
						 * Например, страница № 0 для числа 19: [3, 2_097_155) - последнее нечётное
						 * число, кратное 19: 2_097_144. На следующей странице № 1 [2_097_155,
						 * 4_194_307) необходимо продолжить вычёркивать нечётные числа с шагом 19
						 * начиная с индекса бита bi = p - r = 19 - (2_097_155 - 19^2) % 19 = 8.
						 */

						Starter.logger.info("Определение смещения индекса начала высеивания для p={}, s={}, lowi={}.",
								p, s, lowi);

						long r = (lowi - s) % p;
						s = (r != 0) ? p - r : 0;

						Starter.logger.info("                               ...смещение индекса p={}, s={}, lowi={}.",
								p, s, lowi);

					}

					Starter.logger.info("Просеивание с позиции s={} с шагом p={}", s, p);
					/* Просеивание соответствующих бит. */
					for (int j = (int) s; j < PGSZBITS; j += p) {
						buf[j >> 3] |= (1 << (j & 7));
					}
				}
			}
		}

		/*
		 * Перебор buf в поисках следующего простого числа (т. е. поиск следующего бита
		 * "0"). Цикл извлекает данную восьмёрку бит из buf[], соответствующую данному
		 * индексу бита bi. Затем при помощи смещаемой маски, состоящей из одного
		 * установленного бита, находит следующий неустановленный бит в извлечённой
		 * восьмёрке бит. Если бит не установлен, то число, соответствующее данному
		 * индексу бита - является простым (выход из цикла).
		 */
		while (bi < PGSZBITS && (buf[(int) bi >> 3] & (1 << (bi & 7))) != 0)
			bi++;

		Starter.logger.info("...после перебора решета очередной неустановленный бит bi={}...", bi);

		/*
		 * Индекс бита bi меньше длины PGSZBYTES buf[]. Создание новой страницы не
		 * требуется. Требуется только корректировка возвращаемого просто числа.
		 */
		if (bi < PGSZBITS) {
			/*
			 * Простое число p, восстановленное из индекса бита bi: p = 2 * i + 3, где 3 -
			 * значение, соответствующее нулевому биту нулевой страницы, lowi - индекс
			 * нулевого бита данной страницы. Инкремент bi для следующего вызова next().
			 */

			Starter.logger.info("Простое число на странице № {}, bi={}, p={}.", counter, bi, (3 + ((lowi + bi) << 1)));

			return Long.valueOf(3 + ((lowi + bi++) << 1));
		} else {
			/*
			 * Индекс бита bi оказался больше длины PGSZBITES buf[]. Поэтому сбрасываем
			 * счётчик бит, указываем новую нижнюю границу страницы и углубляемся в
			 * рекурсию.
			 */
			bi = 0;

			/*
			 * Новый индекс нижней границы новой страницы. Выход на рекурсию = создание
			 * новой страницы.
			 */
			lowi += PGSZBITS;
			counter++; // Счётчик созданных страниц.
			prcounter += countPage(PGSZBITS - 1, buf); // Счётчик простых чисел страницы при помощи CLUT.
			return next();
		}
	}

	/**
	 * Считает количество простых чисел на данной странице. Подсчёт происходит путём
	 * отображения бит страницы в виде массива byte[] на массив int[] (биты четырёх
	 * элементов byte[] записываются последовательно в один элемент int[]). Подсчёт
	 * происходит извлечением суммарного числа установленных бит из заранее
	 * подготовленной таблицы поиска CLUT.
	 * 
	 * @param bitlmt индекс последнего бита страницы (первый бит страницы имеет
	 *               индекс 0).
	 * @param buf    просеянная страница.
	 * @return количество неустановленных битов в buf (равных 0, соответствует
	 *         количеству простых чисел на странице).
	 */
	private int countPage(long bitlmt, byte[] buf) {
		/*
		 * Индекс последнего элемента в int[] при трансляции побитово в него byte[].
		 */
		int lst = (int) bitlmt >> 5;

		int bufsz = buf.length;

		/*
		 * Первые 4 элемента byte[] (32 бита) пойдут в первый элемент int[] (32 бита)
		 * подряд.
		 */
		int[] pg = new int[lst + 1];
		for (int i = 0, j = 0; i < bufsz; i++, j = i >> 2) {
			// маска 0xFF для отбрасывания дополнительного кода отрицательного
			// числа.
			pg[j] |= (buf[i] & 0xFF) << (8 * (i & 3));

		}

		/*
		 * Количество бит в массиве int[] с количеством элементов lst. Из этого
		 * количества будет вычитаться количество установленных бит для данного числа,
		 * извлечённое из CLUT. В конце будут так же исключены лишние биты, появившиеся
		 * из-за того, что byte[] buf был не кратен int[] (например, на последний
		 * элемент int[] пришлось два элемента byte[], а не четыре).
		 */
		int cnt = (lst << 5) + 32;

		/*
		 * Обрабатываем все строки int[] pg, который содержит "транслированные" биты
		 * byte[] buf.
		 */
		for (int i = 0; i < lst; ++i) {
			/*
			 * Извлекая из pg[] очередные 32 бита, нарезаем их на две части и извлекаем
			 * количество установленных бит для данного 16-ти битного числа из CLUT.
			 */
			int v = pg[i];
			cnt -= CLUT[v & 0xFFFF]; // 0xFFFF = 0b1111_1111_1111_1111, маска первых 16-ти бит.
			cnt -= CLUT[v >>> 16]; // Биты от 17 до 32.
		}
		/*
		 * Последний/единственный элемент pg[] необходимо обработать отдельно на тот
		 * случай, если последний элемент int[] заполнился не полностью.
		 * 
		 * Например, последний элемент int[] имеет два записанных элемента byte[]:
		 * 0b00000000_00000000_10011001_00111100. Для корректного подсчёта необходимо
		 * установить биты в первых двух группах. Находится остаток деления индекса
		 * последнего бита bitlmt на 32 - результат будет требуемым смещением маски
		 * 0xFFFF_FFFE. Последний бит маски обнулён потому что индексы начинаются с "0"
		 * (маску 0xFFFF_FFFF необходимо было бы продвигать на bitlmt & 31 + 1).
		 */
		int n = pg[lst] | (0xFFFF_FFFE << (bitlmt & 31));
		cnt -= CLUT[n & 0xFFFF];
		cnt -= CLUT[n >>> 16];
		return cnt;
	}

	/**
	 * Переводит данное десятичное число {@code n} в строку, представляющую ровно 8
	 * бит данного числа. Учитывается дополнительный код отрицательного числа.
	 * 
	 * @param n десятичное число для перевода в битовое представление.
	 * @return строка, представляющая 8 бит данного числа.
	 */
	private static String decToBinRaw(int n) {
		int r;
		String filler = "0";
		StringBuilder sb = new StringBuilder();
		// Корректировка для отрицательного числа в дополнительном коде.
		if (n < 0) {
			n++;
			filler = "1";
		}

		do {
			r = n % 2;
			if (n >= 0) {
				sb.append(r);
			} else {
				sb.append(r == -1 ? "0" : "1");
			}
		} while ((n = n / 2) != 0);
		while (sb.length() < 8) {
			sb.append(filler);
		}
		return sb.reverse().toString();
	}

	/**
	 * Переводит массив чисел типа {@code byte[]} в строку бит. Используется
	 * вспомогательный метод {@link BitSievePageSegmented#decToBinRaw decToBinRaw}.
	 * 
	 * @param buf массив с числами для преобразования в битовое представление.
	 * @return строка бит данного числа.
	 */
	private static String toBits(byte[] buf) {
		StringBuilder sb = new StringBuilder().append("[");
		for (int i = 0; i < buf.length; i++) {
			sb.append(decToBinRaw(buf[i])).append(", ");
		}
		sb.delete(sb.length() - 3, sb.length() - 1);
		return sb.append("]").toString();
	}

	/**
	 * Создаёт таблицу поиска, используемую в методе подсчёта количества простых
	 * чисел на данной странице {@link BitSievePageSegmented#countPage(int, int[])
	 * countPage()} (counting lookup table, CLUT). Таблица поиска отображает
	 * количество установленных бит ("1") для данного индекса таблицы поиска.
	 * Экономит ресурсы, затрачиваемые на постоянные сдвиговые операции при поиске
	 * очередного неустановленного бита с индексом {@code bi}, которому
	 * соответствует очередное простое число (см. цикл {@code while} в конце метода
	 * {@link BitSievePageSegmented#next()}). Вместо данного побитового перебора
	 * страницы, страница будет нарезаться на участки по 16 бит. Каждый участок
	 * будет представлять число. Используя данное число как индекс массива
	 * {@code int[] CLUT} можно определить количество установленных бит без битовых
	 * операций.
	 * 
	 * @return массив-таблица поиска, отображающее количество установленных бит для
	 *         числа-индекса.
	 */
	private static int[] generateCLUT() {
		int[] arr = new int[65536];
		for (int i = 0; i < 65536; ++i) {
			int nmbts = 0;
			int v = i;
			/*
			 * Последовательное обнуление числа-индекса i: каждую итерацию из числа
			 * отнимается 1. В битовом виде это значит, что все замыкающие нулевые биты
			 * заменяются на единичные. Последующая конъюнкция обнуляет все замыкающие биты.
			 * Таким образом, количество итераций окажется равным количеству установленных
			 * битов в исходном числе. 1) 0b1110_0001. 2) 0b1110_0001 - 1 = 0b1110_0000. 3)
			 * 0b1110_0001 & 0b1110_0000 = 0b1110_0000. 4) 0b1110_0000 - 1 = 0b1101_11111.
			 * 5) 0b1110_0000 & 0b1101_1111 = 0b1100_0000 и т. д.
			 */
			while (v > 0) {
				++nmbts;
				v &= (v - 1);
			}
			arr[i] = nmbts;
		}
		return arr;
	}
}